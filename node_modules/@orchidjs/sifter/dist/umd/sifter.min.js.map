{"version":3,"file":"sifter.min.js","sources":["../../lib/diacritics.ts","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["\ntype TDiacraticList = {[key:string]:string};\n\n// https://github.com/andrewrk/node-diacritics/blob/master/index.js\nexport const DIACRITICS:TDiacraticList = {\n\t\" \":\" \",\n\t0:\"߀\",\n\tA:\"ⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ\",\n\tAA:\"Ꜳ\",\n\tAE:\"ÆǼǢ\",\n\tAO:\"Ꜵ\",\n\tAU:\"Ꜷ\",\n\tAV:\"ꜸꜺ\",\n\tAY:\"Ꜽ\",\n\tB:\"ⒷＢḂḄḆɃƁ\",\n\tC:\"ⒸＣꜾḈĆCĈĊČÇƇȻ\",\n\tD:\"ⒹＤḊĎḌḐḒḎĐƊƉᴅꝹ\",\n\tDh:\"Ð\",\n\tDZ:\"ǱǄ\",\n\tDz:\"ǲǅ\",\n\tE:\"ɛⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎᴇ\",\n\tF:\"ꝼⒻＦḞƑꝻ\",\n\tG:\"ⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾɢ\",\n\tH:\"ⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ\",\n\tI:\"ⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ\",\n\tJ:\"ⒿＪĴɈȷ\",\n\tK:\"ⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ\",\n\tL:\"ⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ\",\n\tLJ:\"Ǉ\",\n\tLj:\"ǈ\",\n\tM:\"ⓂＭḾṀṂⱮƜϻ\",\n\tN:\"ꞤȠⓃＮǸŃÑṄŇṆŅṊṈƝꞐᴎ\",\n\tNJ:\"Ǌ\",\n\tNj:\"ǋ\",\n\tO:\"ⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ\",\n\tOE:\"Œ\",\n\tOI:\"Ƣ\",\n\tOO:\"Ꝏ\",\n\tOU:\"Ȣ\",\n\tP:\"ⓅＰṔṖƤⱣꝐꝒꝔ\",\n\tQ:\"ⓆＱꝖꝘɊ\",\n\tR:\"ⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ\",\n\tS:\"ⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ\",\n\tT:\"ⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ\",\n\tTh:\"Þ\",\n\tTZ:\"Ꜩ\",\n\tU:\"ⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ\",\n\tV:\"ⓋＶṼṾƲꝞɅ\",\n\tVY:\"Ꝡ\",\n\tW:\"ⓌＷẀẂŴẆẄẈⱲ\",\n\tX:\"ⓍＸẊẌ\",\n\tY:\"ⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ\",\n\tZ:\"ⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ\",\n\ta:\"ⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑ\",\n\taa:\"ꜳ\",\n\tae:\"æǽǣ\",\n\tao:\"ꜵ\",\n\tau:\"ꜷ\",\n\tav:\"ꜹꜻ\",\n\tay:\"ꜽ\",\n\tb:\"ⓑｂḃḅḇƀƃɓƂ\",\n\tc:\"ｃⓒćĉċčçḉƈȼꜿↄ\",\n\td:\"ⓓｄḋďḍḑḓḏđƌɖɗƋᏧԁꞪ\",\n\tdh:\"ð\",\n\tdz:\"ǳǆ\",\n\te:\"ⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇǝ\",\n\tf:\"ⓕｆḟƒ\",\n\tff:\"ﬀ\",\n\tfi:\"ﬁ\",\n\tfl:\"ﬂ\",\n\tffi:\"ﬃ\",\n\tffl:\"ﬄ\",\n\tg:\"ⓖｇǵĝḡğġǧģǥɠꞡꝿᵹ\",\n\th:\"ⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ\",\n\thv:\"ƕ\",\n\ti:\"ⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı\",\n\tj:\"ⓙｊĵǰɉ\",\n\tk:\"ⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ\",\n\tl:\"ⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇɭ\",\n\tlj:\"ǉ\",\n\tm:\"ⓜｍḿṁṃɱɯ\",\n\tn:\"ⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥлԉ\",\n\tnj:\"ǌ\",\n\to:\"ⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿꝋꝍɵɔᴑ\",\n\toe:\"œ\",\n\toi:\"ƣ\",\n\too:\"ꝏ\",\n\tou:\"ȣ\",\n\tp:\"ⓟｐṕṗƥᵽꝑꝓꝕρ\",\n\tq:\"ⓠｑɋꝗꝙ\",\n\tr:\"ⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ\",\n\ts:\"ⓢｓśṥŝṡšṧṣṩșşȿꞩꞅẛʂ\",\n\tss:\"ß\",\n\tt:\"ⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ\",\n\tth:\"þ\",\n\ttz:\"ꜩ\",\n\tu:\"ⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ\",\n\tv:\"ⓥｖṽṿʋꝟʌ\",\n\tvy:\"ꝡ\",\n\tw:\"ⓦｗẁẃŵẇẅẘẉⱳ\",\n\tx:\"ⓧｘẋẍ\",\n\ty:\"ⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ\",\n\tz:\"ⓩｚźẑżžẓẕƶȥɀⱬꝣ\"\n}\n\n/**\n * code points generated from toCodePoints();\n * removed 65339 to 65345\n */\nvar code_points = [\n\t[ 67, 67 ],\n\t[ 160, 160 ],\n\t[ 192, 438 ],\n\t[ 452, 652 ],\n\t[ 961, 961 ],\n\t[ 1019, 1019 ],\n\t[ 1083, 1083 ],\n\t[ 1281, 1289 ],\n\t[ 1984, 1984 ],\n\t[ 5095, 5095 ],\n\t[ 7429, 7441 ],\n\t[ 7545, 7549 ],\n\t[ 7680, 7935 ],\n\t[ 8580, 8580 ],\n\t[ 9398, 9449 ],\n\t[ 11360, 11391 ],\n\t[ 42792, 42793 ],\n\t[ 42802, 42851 ],\n\t[ 42873, 42897 ],\n\t[ 42912, 42922 ],\n\t[ 64256, 64260 ],\n\t[ 65313, 65338 ],\n\t[ 65345, 65370 ]\n];\n\n/**\n * Remove accents\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n *\n */\nexport const asciifold = (str:string):string => {\n\treturn str.normalize('NFD').replace(/[\\u0300-\\u036F]/g, '').normalize('NFKD').toLowerCase();\n};\n\n\n/**\n * Convert list of diacritics to array of code points\n *\n */\n// @ts-ignore\nfunction toCodePoints(tolerance=8){\n\tvar char_codes:number[] = [];\n\n\tfor( let letter in DIACRITICS ){\n\t\tlet _diacritics = DIACRITICS[letter];\n\t\tfor( let n = 0; n < _diacritics.length; n++ ){\n\t\t\tvar code_point = _diacritics.codePointAt(n);\n\t\t\tif( code_point ) char_codes.push( code_point );\n\t\t}\n\t}\n\n\t//https://stackoverflow.com/questions/40431572/is-there-a-simple-way-to-group-js-array-values-by-range\n\tchar_codes.sort((a, b) => a - b);\n\tvar accumulator: number[][] = [];\n    var result = char_codes.reduce(function (accumulator, currentValue, index, source) {\n\n\t\tif( !index ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else if( currentValue - source[index - 1] > tolerance ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else{\n\n\t\t\tlet range = accumulator.pop();\n\t\t\tif( range ){\n\t\t\t\taccumulator.push( [range[0],currentValue]);\n\t\t\t}\n\t\t}\n\n        return accumulator;\n    }, accumulator);\n\n\tconsole.log(`char_codes (${result.length})`,result);\n}\n\n/**\n * Generate a list of diacritics from the list of code points\n *\n */\nexport const generateDiacritics = ():TDiacraticList => {\n\n\tvar latin_convert:{[key:string]:string} = {\n\t\t'l·': 'l',\n\t\t'ʼn': 'n',\n\t\t'æ': 'ae',\n\t\t'ø': 'o',\n\t\t'aʾ': 'a',\n\t\t'dž': 'dz',\n\t};\n\n\tvar diacritics:{[key:string]:string} = {};\n\t//var no_latin\t= [];\n\tcode_points.forEach((code_range)=>{\n\n\t\tfor(let i = code_range[0]; i <= code_range[1]; i++){\n\t\t\tlet diacritic\t= String.fromCharCode(i);\n\t\t\tlet latin\t\t= diacritic.normalize('NFD').replace(/[\\u0300-\\u036F]/g, '').normalize('NFKD');\n\n\t\t\tif( latin == diacritic ){\n\t\t\t\t//no_latin.push(diacritic);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlatin = latin.toLowerCase();\n\n\t\t\tif( latin in latin_convert ){\n\t\t\t\tlatin = latin_convert[latin];\n\t\t\t}\n\n\t\t\tif( !(latin in diacritics) ){\n\t\t\t\tdiacritics[latin] = latin + latin.toUpperCase();\n\t\t\t}\n\t\t\tdiacritics[latin] += diacritic;\n\t\t}\n\t});\n\n\t//console.log('no_latin',JSON.stringify(no_latin));\n\n\treturn diacritics;\n}\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n */\nvar diacritics:null|TDiacraticList = null\nexport const diacriticRegexPoints = (regex:string):string => {\n\n\tif( diacritics === null ){\n\t\tdiacritics = generateDiacritics();\n\t}\n\n\tfor( let latin in diacritics ){\n\t\tif( diacritics.hasOwnProperty(latin) ){\n\t\t\tregex = regex.replace( new RegExp(latin,'g'), '['+diacritics[latin]+']');\n\t\t}\n\t}\n\treturn regex;\n}\n\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * rollup will bundle this function (and the DIACRITICS constant) unless commented out\n *\nvar diacriticRegex = (function() {\n\n\tvar list = [];\n\tfor( let letter in DIACRITICS ){\n\n\t\tif( letter.toLowerCase() != letter && letter.toLowerCase() in DIACRITICS ){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( DIACRITICS.hasOwnProperty(letter) ){\n\n\t\t\tvar replace = letter + DIACRITICS[letter];\n\t\t\tif( letter.toUpperCase() in DIACRITICS ){\n\t\t\t\treplace += letter.toUpperCase() + DIACRITICS[letter.toUpperCase()];\n\t\t\t}\n\n\t\t\tlist.push({let:letter,pat:'['+replace+']'});\n\t\t}\n\t}\n\n\treturn function(regex:string):string{\n\t\tlist.forEach((item)=>{\n\t\t\tregex = regex.replace( new RegExp(item.let,'g'),item.pat);\n\t\t});\n\t\treturn regex;\n\t}\n})();\n*/\n","\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { asciifold } from './diacritics.ts';\n\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\nexport const escape_regex = (str:string):string => {\n\treturn (str + '').replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:number|string)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\n // @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { scoreValue, getAttr, getAttrNesting, escape_regex, propToArray, iterate, cmp } from './utils.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { diacriticRegexPoints, asciifold } from './diacritics.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from 'types.ts';\n\nexport default class Sifter{\n\n\tpublic items; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1];\n\t\t\t\tword\t= field_match[2];\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tregex = escape_regex(word);\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = diacriticRegexPoints(regex);\n\t\t\t\t}\n\t\t\t\tif( respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'i') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {function}\n\t */\n\tgetScoreFunction(query:string, options:T.Options ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0].field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0], data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar i = 0, score, sum = 0;\n\t\t\t\tfor (; i < token_count; i++) {\n\t\t\t\t\tscore = scoreObject(tokens[i], data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.Options) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar i, n, implicit_score;\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort,\n\t\tsort_flds:T.Sort[]\t\t= [],\n\t\tmultipliers:number[]\t= [];\n\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor (i = 0, n = sort.length; i < n; i++) {\n\t\t\t\tif (search.query || sort[i].field !== '$score') {\n\t\t\t\t\tsort_flds.push(sort[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\tsort_flds.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\tmultipliers.push(sort_flds[i].direction === 'desc' ? -1 : 1);\n\t\t}\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t} else if (sort_flds_count === 1) {\n\t\t\tconst sort_fld = sort_flds[0].field;\n\t\t\tconst multiplier = multipliers[0];\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\treturn multiplier * cmp(\n\t\t\t\t\tget_field(sort_fld, a),\n\t\t\t\t\tget_field(sort_fld, b)\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\tvar i, result, field;\n\t\t\t\tfor (i = 0; i < sort_flds_count; i++) {\n\t\t\t\t\tfield = sort_flds[i].field;\n\t\t\t\t\tresult = multipliers[i] * cmp(\n\t\t\t\t\t\tget_field(field, a),\n\t\t\t\t\t\tget_field(field, b)\n\t\t\t\t\t);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.Options):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser);\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\t\tquery = asciifold( query + '' ).toLowerCase().trim();\n\n\t\treturn {\n\t\t\toptions\t\t: options,\n\t\t\tquery\t\t: query,\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.Options) : T.PrepareObj {\n\t\tvar self = this, score, search:T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n"],"names":["code_points","asciifold","str","normalize","replace","toLowerCase","diacritics","diacriticRegexPoints","regex","latin_convert","forEach","code_range","i","diacritic","String","fromCharCode","latin","toUpperCase","generateDiacritics","hasOwnProperty","RegExp","getAttr","obj","name","getAttrNesting","part","names","split","shift","scoreValue","value","token","weight","score","pos","search","string","length","escape_regex","propToArray","key","Array","isArray","iterate","object","callback","cmp","a","b","constructor","items","settings","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","Object","keys","map","join","word","field_match","field","match","this","push","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","n","implicit_score","self","sort","sort_empty","sort_flds","multipliers","get_field","result","id","unshift","direction","splice","sort_flds_count","sort_fld","multiplier","optsUser","assign","trim","total","nesting","fn_score","item","filter","fn_sort","limit","slice"],"mappings":"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"}